import os
from pathlib import Path
from typing import List


REPO_DIR = Path(os.path.realpath(""))
INFERENCE_DATA_PATH = REPO_DIR / "data/sample_for_inference.csv"
TRAINING_DATA_PATH = REPO_DIR / "data/BankChurners.csv"


class PreprocessConfig:
    train_path = REPO_DIR / "data/preprocessed/train.parquet"
    test_path = REPO_DIR / "data/preprocessed/test.parquet"
    batch_path = REPO_DIR / "data/preprocessed/batch.parquet"
    dropped_col_names = [
        "CLIENTNUM"
        , "Naive_Bayes_Classifier_Attrition_Flag_Card_Category_Contacts_Count_12_mon_Dependent_count_Education_Level_Months_Inactive_12_mon_1"
        , "Naive_Bayes_Classifier_Attrition_Flag_Card_Category_Contacts_Count_12_mon_Dependent_count_Education_Level_Months_Inactive_12_mon_2"
    ] #  2 last cols are directly correlated to the target
    target = "Attrition_Flag"


class TrainerConfig:
    random_state = 42
    train_size = 0.67
    shuffle = True
    estimator = {
        'GradientBoostingClassifier': {
            "model_name": "gradient-boosting",
            "params": {
                        "n_estimators": 100,
                        "min_samples_split": 2,
                        "min_samples_leaf": 1
            }
        },
        'LogisticRegression': {
            "model_name": "logistic-regression",
            "params": {
                        "C": 0.5,
                        "solver": "newton-cg"
            }
        }
    }
    gradient_boosting = "GradientBoostingClassifier"
    logistic_regression = "LogisticRegression"

class ConditionConfig:
    criteria = 0.01
    metric = "roc_auc"

class MlFlowConfig:
    uri = "http://host.docker.internal:5050"
    experiment_name = "churn_prediction"
    artifact_path = "model-artifact"
    registered_model_name = "churn_prediction"
    tag_key = "model"

class FeatureEngineeringConfig:
    train_path = REPO_DIR / "data/features_store/train.parquet"
    test_path = REPO_DIR / "data/features_store/test.parquet"
    batch_path = REPO_DIR / "data/features_store/batch.parquet"
    encoders_path = REPO_DIR / "artifacts/encoders.joblib"
    target = "Attrition_Flag"
    base_features = [
        "Customer_Age",
        "Dependent_count",
        "Months_on_book",
        "Total_Relationship_Count",
        "Months_Inactive_12_mon",
        "Contacts_Count_12_mon",
        "Credit_Limit",
        "Total_Revolving_Bal",
        "Avg_Open_To_Buy",
        "Total_Amt_Chng_Q4_Q1",
        "Total_Trans_Amt",
        "Total_Trans_Ct",
        "Total_Ct_Chng_Q4_Q1",
        "Avg_Utilization_Ratio",
    ]
    ordinal_features = [
        "Education_Level",
        "Income_Category",
        "Card_Category"
    ]
    onehot_features = [
        "Gender",
        "Marital_Status"        
    ]
    # Use OrdinalEncoder for ordinal data, and OneHotEncoder for nominal data.
    cate_features_info = {
        'Gender': {
            'type': 'nominal',
            'names': ['Gender_F', 'Gender_M'],
            'categories': ['F', 'M']
        },
        'Education_Level': {
            'type': 'ordinal',
            'ranking': ['Uneducated', 'High School', 'College', 'Graduate', 'Post-Graduate', 'Doctorate']
        },
        'Marital_Status': {
            'type': 'nominal',
            'names': ['Marital_Status_Divorced', 'Marital_Status_Married', 'Marital_Status_Single'],
            'categories': ['Divorced', 'Married', 'Single']
        },
        'Income_Category': {
            'type': 'ordinal',
            'ranking': ['Less than $40K', '$40K - $60K', '$60K - $80K', '$80K - $120K', '$120K +']
        },
        'Card_Category': {
            'type': 'ordinal',
            'ranking': ['Blue', 'Silver', 'Gold', 'Platinum']
        }
    }

    @classmethod
    def get_ordinal_cates(cls):
        """
        Get predefined categories order of ordinal features
        """
        # Detect ordinal columns and their rankings
        ordinal_features = {k: v for k, v in cls.cate_features_info.items() if v['type'] == 'ordinal'}
        for feature, info in ordinal_features.items():
            yield f"{feature}: {info['ranking']}"
    @classmethod
    def get_onehot_names(cls):
        """
        Get category column names generated by OneHotEncoder
        """
        nominal_features = {k: v for k, v in cls.cate_features_info.items() if v['type'] == 'nominal'}
        for feature, info in nominal_features.items():
            yield f"{feature}: {info['names']}"

    @classmethod
    def get_onehot_cates(cls):
        """
        Get predefined categories value of onehot features
        """
        nominal_features = {k: v for k, v in cls.cate_features_info.items() if v['type'] == 'nominal'}
        for feature, info in nominal_features.items():
            yield f"{feature}: {info['categories']}"

    def create_expected_ordinal_cates_order() -> List[List]:
        ordinal_cates = [feature_ranking for feature_ranking in FeatureEngineeringConfig.get_ordinal_cates()]
        # Convert to dictionary
        ordinal_cates_dict = {}
        for item in ordinal_cates:
            key, value = item.split(": ", 1)
            ordinal_cates_dict[key] = eval(value)  # Convert the string representation of the list to an actual list
        print(ordinal_cates_dict)
        categories = [[ranking for ranking in ordinal_cates_dict[feature]] for feature in FeatureEngineeringConfig.ordinal_features] # this process ensure order features are consistancy with the config
        print(categories)
        return categories

    def create_expected_onehot_names_order() -> List[List]:
        onehot_names = [item for item in FeatureEngineeringConfig.get_onehot_names()]
        # Convert to dictionary
        onehot_names_dict = {}
        for item in onehot_names:
            key, value = item.split(": ", 1)
            onehot_names_dict[key] = eval(value)  # Convert the string representation of the list to an actual list
        print(onehot_names_dict)
        names = [[item for item in onehot_names_dict[feature]] for feature in FeatureEngineeringConfig.onehot_features] # this process ensure order features are consistancy with the config
        print(names)
        return names

    def create_expected_onehot_categories_order() -> List[List]:
        onehot_cates = [item for item in FeatureEngineeringConfig.get_onehot_cates()]
        # Convert to dictionary
        onehot_cates_dict = {}
        for item in onehot_cates:
            key, value = item.split(": ", 1)
            onehot_cates_dict[key] = eval(value)  # Convert the string representation of the list to an actual list
        print(onehot_cates_dict)
        categories = [[item for item in onehot_cates_dict[feature]] for feature in FeatureEngineeringConfig.onehot_features] # this process ensure order features are consistancy with the config
        print(categories)
        return categories